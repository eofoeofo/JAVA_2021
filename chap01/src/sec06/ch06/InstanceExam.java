package sec06.ch06; // 현재 경로 + 클래스name까지가 이 java파일의 풀네임
// 패키지는 구별하기 위한 용도, 같은 이름의 InstanceExam라도 패키지 경로가 다르면 다른파일.
// 자바 기준, 패키지명은 소문자만 사용한다.

// public는 자바파일명의 클래스에게만 붙일수있다.
public class InstanceExam {

	public static void main(String[] args) {
		Dog dog = new Dog(); // new!! - 래미안 아파트는 구조가 같지만, 서울래미안과 대구래미안은 주소가 다르다!!
							 // 같은 구조에, 다른 값을 저장할 수 있다.(구조만 같고 다른 객체니까)
		Dog d2 = new Dog(); // 객체가 아닌 클래스를 객체화 시키는 과정(Instance화 시킨다)
	//맨앞 Dog는 타입이 될 수있다. // (레퍼런스타입) // new는 객체화를 시켜주는 키워드 이다(동적 객체화).
		// new는 객체화., 마지막 Dog()(객체) 의 메모리의 주소값을 복사하여 dog에 주는것.
		// dog에 주소값을 준다. 계속 존재하는 개념
//		new Dog(); 1회성이다.
		//Dog,String이나 레퍼런스타입은 무조건 주소값을 받는것이다.
//		String sss = new String("d");
		// 같은 주소값이라도 타입이 다르다면 서로 주고받을 수 없다
//		Dog d = sss; 16Line의 주석처럼 타입이 다르기에 값을 줄 수 없다.
		dog.bark(); // 주소값.멤버필드or멤버메소드();
		// 접근은 (.이다) 한다는것은 명령 할 수 있고, 
		// 호출할 수 있고, 수정할 수 있고, 다 할수있다.
		// static은 new 키워드없이 메모리에 올리는 키워드
		dog.name = "뽀삐";
		d2.name = "돌쇠";
		dog.bark();
		d2.bark();
	}

}
// 객체가 되는 존재 {}시작과 끝
// 이름이 있으면 객체,라고함, 현실세계를 반영하기 위함?
// 클래스 구성, 멤버 필드, 멤버 메소드
// 멤버 필드, ( 값을 저장할 수 있는 것 ) - 명사 담당. // 생략은 가능하다.
// 멤버 메소드, ( 값을 수정할 수 있는 것 ) - 동사 담당. // 생략 가능
// 객체를 만들어서 문제?를 해결해나가는게 객체지향의 특징
// 기능별로 세분화 시키는것이 객체지향
// 클래스명은 항상 대문자
class Dog { // 클래스 == 설계도(실체는 객체, 클래스는 객체가 아니다)
	String name; // 멤버 필드는 전역변수( 클래스 내부에서만 사용 가능 )
	String jong;
	int age;
	
	void bark() {
//		String name1; //지역변수
		System.out.printf("%s가 멍멍\n",name);
	}

}
